import { JWTExpiredError } from './api/utils/Errors';
import { parse } from './util/base64url';
import { isDevelopmentOrStaging, isProduction } from './util/clerkApiKey';
import { checkClaims, isExpired } from './util/jwt';
import { checkCrossOrigin } from './util/request';
export const API_KEY = process.env.CLERK_API_KEY || '';
export var AuthStatus;
(function (AuthStatus) {
    AuthStatus["SignedIn"] = "Signed in";
    AuthStatus["SignedOut"] = "Signed out";
    AuthStatus["Interstitial"] = "Interstitial";
})(AuthStatus || (AuthStatus = {}));
const verifySessionTokenDefaultOptions = {
    authorizedParties: [],
};
export class Base {
    constructor(importKeyFunction, verifySignatureFunction, decodeBase64Function, loadCryptoKeyFunction) {
        this.verifySessionToken = async (token, { authorizedParties } = verifySessionTokenDefaultOptions) => {
            const availableKey = this.loadCryptoKeyFunction
                ? await this.loadCryptoKeyFunction(token)
                : await this.loadCryptoKeyFromEnv();
            const claims = await this.verifyJwt(availableKey, token);
            checkClaims(claims, authorizedParties);
            return claims;
        };
        this.loadCryptoKeyFromEnv = async () => {
            const key = process.env.CLERK_JWT_KEY;
            if (!key) {
                throw new Error('Missing jwt key');
            }
            const RSA_PREFIX = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA';
            const RSA_SUFFIX = 'IDAQAB';
            const jwk = {
                kty: 'RSA',
                n: key
                    .slice(RSA_PREFIX.length, RSA_SUFFIX.length * -1)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_'),
                e: 'AQAB',
            };
            const algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: 'SHA-256',
            };
            return this.importKeyFunction(jwk, algorithm);
        };
        this.decodeJwt = (token) => {
            const tokenParts = token.split('.');
            if (tokenParts.length !== 3) {
                throw new Error('Malformed token');
            }
            const [rawHeader, rawPayload, rawSignature] = tokenParts;
            const header = JSON.parse(this.decodeBase64Function(rawHeader));
            const payload = JSON.parse(this.decodeBase64Function(rawPayload));
            const signature = this.decodeBase64Function(rawSignature.replace(/_/g, '/').replace(/-/g, '+'));
            return {
                header,
                payload,
                signature,
            };
        };
        this.verifyJwtSignature = async (key, token) => {
            const [rawHeader, rawPayload, rawSignature] = token.split('.');
            const encoder = new TextEncoder();
            const data = encoder.encode([rawHeader, rawPayload].join('.'));
            const signature = parse(rawSignature);
            const isVerified = await this.verifySignatureFunction('RSASSA-PKCS1-v1_5', key, signature, data);
            if (!isVerified) {
                throw new Error('Failed to verify token');
            }
        };
        this.verifyJwt = async (key, token) => {
            const { payload } = this.decodeJwt(token);
            await this.verifyJwtSignature(key, token);
            isExpired(payload);
            return payload;
        };
        this.getAuthState = async ({ cookieToken, clientUat, headerToken, origin, host, forwardedHost, forwardedPort, referrer, userAgent, authorizedParties, fetchInterstitial, }) => {
            const isCrossOrigin = checkCrossOrigin(origin, host, forwardedHost, forwardedPort);
            let sessionClaims;
            if (headerToken) {
                try {
                    sessionClaims = await this.verifySessionToken(headerToken, { authorizedParties });
                    return {
                        status: AuthStatus.SignedIn,
                        session: {
                            id: sessionClaims.sid,
                            userId: sessionClaims.sub,
                        },
                        sessionClaims,
                    };
                }
                catch (err) {
                    if (err instanceof JWTExpiredError) {
                        return {
                            status: AuthStatus.Interstitial,
                            interstitial: await fetchInterstitial(),
                        };
                    }
                    else {
                        return { status: AuthStatus.SignedOut };
                    }
                }
            }
            if (isDevelopmentOrStaging(API_KEY) && !userAgent?.startsWith('Mozilla/')) {
                return { status: AuthStatus.SignedOut };
            }
            if (isCrossOrigin) {
                return { status: AuthStatus.SignedOut };
            }
            if (isDevelopmentOrStaging(API_KEY) && !clientUat) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                };
            }
            if (isDevelopmentOrStaging(API_KEY) &&
                referrer &&
                checkCrossOrigin(new URL(referrer).origin, host, forwardedHost, forwardedPort)) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                };
            }
            if (isProduction(API_KEY) && !clientUat && !cookieToken) {
                return { status: AuthStatus.SignedOut };
            }
            if (clientUat === '0') {
                return { status: AuthStatus.SignedOut };
            }
            if (isProduction(API_KEY) && clientUat && !cookieToken) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                };
            }
            try {
                sessionClaims = await this.verifySessionToken(cookieToken, { authorizedParties });
            }
            catch (err) {
                if (err instanceof JWTExpiredError) {
                    return {
                        status: AuthStatus.Interstitial,
                        interstitial: await fetchInterstitial(),
                    };
                }
                else {
                    return { status: AuthStatus.SignedOut };
                }
            }
            if (cookieToken &&
                clientUat &&
                sessionClaims?.iat &&
                sessionClaims.iat >= Number(clientUat)) {
                return {
                    status: AuthStatus.SignedIn,
                    session: {
                        id: sessionClaims.sid,
                        userId: sessionClaims.sub,
                    },
                    sessionClaims,
                };
            }
            return {
                status: AuthStatus.Interstitial,
                interstitial: await fetchInterstitial(),
            };
        };
        this.importKeyFunction = importKeyFunction;
        this.verifySignatureFunction = verifySignatureFunction;
        this.decodeBase64Function = decodeBase64Function;
        this.loadCryptoKeyFunction = loadCryptoKeyFunction;
    }
}
