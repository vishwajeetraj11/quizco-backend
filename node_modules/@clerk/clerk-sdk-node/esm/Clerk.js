import { AuthStatus, Base, ClerkBackendAPI, } from '@clerk/backend-core';
import Cookies from 'cookies';
import deepmerge from 'deepmerge';
import got from 'got';
import jwt from 'jsonwebtoken';
import jwks from 'jwks-rsa';
import querystring from 'querystring';
import { SupportMessages } from './constants/SupportMessages';
import { LIB_NAME, LIB_VERSION } from './info';
// utils
import Logger from './utils/Logger';
const defaultApiKey = process.env.CLERK_API_KEY || '';
const defaultApiVersion = process.env.CLERK_API_VERSION || 'v1';
const defaultServerApiUrl = process.env.CLERK_API_URL || 'https://api.clerk.dev';
const JWKS_MAX_AGE = 3600000; // 1 hour
const packageRepo = 'https://github.com/clerkinc/clerk-sdk-node';
import { Crypto } from '@peculiar/webcrypto';
import { decodeBase64, toSPKIDer } from './utils/crypto';
const crypto = new Crypto();
const importKey = async (jwk, algorithm) => {
    return await crypto.subtle.importKey('jwk', jwk, algorithm, true, ['verify']);
};
const verifySignature = async (algorithm, key, signature, data) => {
    return await crypto.subtle.verify(algorithm, key, signature, data);
};
export default class Clerk extends ClerkBackendAPI {
    constructor({ apiKey = defaultApiKey, serverApiUrl = defaultServerApiUrl, apiVersion = defaultApiVersion, httpOptions = {}, jwksCacheMaxAge = JWKS_MAX_AGE, } = {}) {
        const fetcher = (url, { method, authorization, contentType, userAgent, body }) => {
            const finalHTTPOptions = deepmerge(this.httpOptions, {
                method,
                responseType: contentType === 'text/html' ? 'text' : 'json',
                headers: {
                    authorization,
                    'Content-Type': contentType,
                    'User-Agent': userAgent,
                    'X-Clerk-SDK': `node/${LIB_VERSION}`,
                },
                // @ts-ignore
                ...(body && { body: querystring.stringify(body) }),
            });
            return got(url, finalHTTPOptions).then((data) => data.body);
        };
        super({
            apiKey: defaultApiKey,
            apiVersion: defaultApiVersion,
            serverApiUrl: defaultServerApiUrl,
            libName: LIB_NAME,
            libVersion: LIB_VERSION,
            packageRepo,
            fetcher,
        });
        if (!apiKey) {
            throw Error(SupportMessages.API_KEY_NOT_FOUND);
        }
        this.httpOptions = httpOptions;
        this._jwksClient = jwks({
            jwksUri: `${serverApiUrl}/${apiVersion}/jwks`,
            requestHeaders: {
                Authorization: `Bearer ${defaultApiKey}`,
            },
            timeout: 5000,
            cache: true,
            cacheMaxAge: jwksCacheMaxAge,
        });
        const loadCryptoKey = async (token) => {
            const decoded = jwt.decode(token, { complete: true });
            if (!decoded) {
                throw new Error(`Failed to decode token: ${token}`);
            }
            const signingKey = await this._jwksClient.getSigningKey(decoded.header.kid);
            const pubKey = signingKey.getPublicKey();
            return await crypto.subtle.importKey('spki', toSPKIDer(pubKey), {
                name: 'RSASSA-PKCS1-v1_5',
                hash: 'SHA-256',
            }, true, ['verify']);
        };
        /** Base initialization */
        this.base = new Base(importKey, verifySignature, decodeBase64, loadCryptoKey);
    }
    async verifyToken(token, authorizedParties) {
        const decoded = jwt.decode(token, { complete: true });
        if (!decoded) {
            throw new Error(`Failed to verify token: ${token}`);
        }
        const key = await this._jwksClient.getSigningKey(decoded.header.kid);
        const verified = jwt.verify(token, key.getPublicKey(), {
            algorithms: ['RS256'],
        });
        if (typeof verified === 'string' || !verified.iss) {
            throw new Error('Malformed token');
        }
        if (!verified.iss || !verified.iss.startsWith('https://clerk')) {
            throw new Error(`Issuer is invalid: ${verified.iss}`);
        }
        if (verified.azp && authorizedParties && authorizedParties.length > 0) {
            if (!authorizedParties.includes(verified.azp)) {
                throw new Error(`Authorized party is invalid: ${verified.azp}`);
            }
        }
        return verified;
    }
    // For use as singleton, always returns the same instance
    static getInstance() {
        if (!this._instance) {
            this._instance = new Clerk();
        }
        return this._instance;
    }
    // Middlewares
    // defaultOnError swallows the error
    defaultOnError(error) {
        Logger.warn(error.message);
        (error.data || []).forEach((serverError) => {
            Logger.warn(serverError.longMessage);
        });
    }
    // strictOnError returns the error so that Express will halt the request chain
    strictOnError(error) {
        Logger.error(error.message);
        (error.data || []).forEach((serverError) => {
            Logger.error(serverError.longMessage);
        });
        return error;
    }
    expressWithSession({ onError, authorizedParties } = { onError: this.defaultOnError }) {
        function signedOut() {
            throw new Error('Unauthenticated');
        }
        async function authenticate(req, res, next) {
            var _a;
            const cookies = new Cookies(req, res);
            try {
                const { status, session, interstitial, sessionClaims } = await this.base.getAuthState({
                    cookieToken: cookies.get('__session'),
                    clientUat: cookies.get('__client_uat'),
                    headerToken: (_a = req.headers.authorization) === null || _a === void 0 ? void 0 : _a.replace('Bearer ', ''),
                    origin: req.headers.origin,
                    host: req.headers.host,
                    forwardedPort: req.headers['x-forwarded-port'],
                    forwardedHost: req.headers['x-forwarded-host'],
                    referrer: req.headers.referer,
                    userAgent: req.headers['user-agent'],
                    authorizedParties: authorizedParties,
                    fetchInterstitial: () => this.fetchInterstitial(),
                });
                if (status === AuthStatus.SignedOut) {
                    return signedOut();
                }
                if (status === AuthStatus.SignedIn) {
                    // @ts-ignore
                    req.session = session;
                    // @ts-ignore
                    req.sessionClaims = sessionClaims;
                    return next();
                }
                res.writeHead(401, { 'Content-Type': 'text/html' });
                res.write(interstitial);
                res.end();
            }
            catch (error) {
                // Session will not be set on request
                // Call onError if provided
                if (!onError) {
                    return next();
                }
                const err = await onError(error);
                if (err) {
                    next(err);
                }
                else {
                    next();
                }
            }
        }
        return authenticate.bind(this);
    }
    expressRequireSession({ onError, authorizedParties } = { onError: this.strictOnError }) {
        return this.expressWithSession({ onError, authorizedParties });
    }
    // Credits to https://nextjs.org/docs/api-routes/api-middlewares
    // Helper method to wait for a middleware to execute before continuing
    // And to throw an error when an error happens in a middleware
    // @ts-ignore
    _runMiddleware(req, res, fn) {
        return new Promise((resolve, reject) => {
            // @ts-ignore
            fn(req, res, (result) => {
                if (result instanceof Error) {
                    return reject(result);
                }
                return resolve(result);
            });
        });
    }
    // Set the session on the request and then call provided handler
    withSession(handler, { onError, authorizedParties } = { onError: this.defaultOnError }) {
        return async (req, res, next) => {
            try {
                await this._runMiddleware(req, res, this.expressWithSession({ onError, authorizedParties }));
                return handler(req, res, next);
            }
            catch (error) {
                // @ts-ignore
                const errorData = error.data || { error: error.message };
                // @ts-ignore
                res.statusCode = error.statusCode || 401;
                /**
                 * Res.json is available in express-like environments.
                 * Res.send is available in express-like but also Fastify.
                 */
                res.json ? res.json(errorData) : res.send(errorData);
                res.end();
            }
        };
    }
    // Stricter version, short-circuits if session can't be determined
    requireSession(handler, { onError, authorizedParties } = { onError: this.strictOnError }) {
        return this.withSession(handler, { onError, authorizedParties });
    }
}
//# sourceMappingURL=Clerk.js.map